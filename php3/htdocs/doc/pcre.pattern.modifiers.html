<HTML
><HEAD
><TITLE
>Pattern Modifiers</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.57"><LINK
REL="HOME"
TITLE="PHP Manual"
HREF="manual.html"><LINK
REL="UP"
TITLE="Regular Expression Functions (Perl-Compatible)"
HREF="ref.pcre.html"><LINK
REL="PREVIOUS"
TITLE="preg_grep"
HREF="function.preg-grep.html"><LINK
REL="NEXT"
TITLE="Pattern Syntax"
HREF="pcre.pattern.syntax.html"><META
NAME="HTTP_EQUIV"
CONTENT="text/html; charset=ISO-8859-1"></HEAD
><BODY
CLASS="refentry"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PHP Manual</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="function.preg-grep.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="pcre.pattern.syntax.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="pcre.pattern.modifiers"
>Pattern Modifiers</A
></H1
><DIV
CLASS="refnamediv"
><A
NAME="AEN33102"
></A
><P
>    (unknown)</P
>Pattern Modifiers&nbsp;--&nbsp;Describes possible modifiers in regex
     patterns</DIV
><DIV
CLASS="refsect1"
><A
NAME="AEN33105"
></A
><H2
>Description</H2
><P
>&#13;     The current possible PCRE modifiers are listed below.  The names
     in parentheses refer to internal PCRE names for these modifiers.
    </P
><P
>&#13;     <A
NAME="AEN33109"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
><I
CLASS="emphasis"
>i</I
> (PCRE_CASELESS)</DT
><DD
><P
>&#13;	  If this modifier is set, letters in the pattern match both
	  upper and lower case letters.
	 </P
></DD
><DT
><I
CLASS="emphasis"
>m</I
> (PCRE_MULTILINE)</DT
><DD
><P
>&#13;	  By default, PCRE treats the subject string as consisting of a
	  single "line" of characters (even if it actually contains
	  several newlines). The "start of line" metacharacter (^)
	  matches only at the start of the string, while the "end of
	  line" metacharacter ($) matches only at the end of the
	  string, or before a terminating newline (unless
	  <I
CLASS="emphasis"
>E</I
> modifier is set). This is the same as
	  Perl.
	 </P
><P
>&#13;	  When this modifier is set, the "start of line" and "end of
	  line" constructs match immediately following or immediately
	  before any newline in the subject string, respectively, as
	  well as at the very start and end. This is equivalent to
	  Perl's /m modifier. If there are no "\n" characters in a
	  subject string, or no occurrences of ^ or $ in a pattern,
	  setting this modifier has no effect.
	 </P
></DD
><DT
><I
CLASS="emphasis"
>s</I
> (PCRE_DOTALL)</DT
><DD
><P
>&#13;	  If this modifier is set, a dot metacharater in the pattern
	  matches all characters, including newlines. Without it,
	  newlines are excluded. This modifier is equivalent to Perl's
	  /s modifier.  A negative class such as [^a] always matches a
	  newline character, independent of the setting of this
	  modifier.
	 </P
></DD
><DT
><I
CLASS="emphasis"
>x</I
> (PCRE_EXTENDED)</DT
><DD
><P
>&#13;	  If this modifier is set, whitespace data characters in the
	  pattern are totally ignored except when escaped or inside a
	  character class, and characters between an unescaped #
	  outside a character class and the next newline character,
	  inclusive, are also ignored. This is equivalent to Perl's /x
	  modifier, and makes it possible to include comments inside
	  complicated patterns. Note, however, that this applies only
	  to data characters. Whitespace characters may never appear
	  within special character sequences in a pattern, for example
	  within the sequence (?( which introduces a conditional
	  subpattern.
	 </P
></DD
><DT
><I
CLASS="emphasis"
>e</I
></DT
><DD
><P
>&#13;	  If this modifier is set, <A
HREF="function.preg-replace.html"
><B
CLASS="function"
>preg_replace()</B
></A
>
	  does normal substitution of \\ references in the
	  replacement string, evaluates it as PHP code, and uses the
	  result for replacing the search string.
	 </P
><P
>&#13;	  Only <A
HREF="function.preg-replace.html"
><B
CLASS="function"
>preg_replace()</B
></A
> uses this modifier;
	  it is ignored by other PCRE functions.
	 </P
></DD
><DT
><I
CLASS="emphasis"
>A</I
> (PCRE_ANCHORED)</DT
><DD
><P
>&#13;	  If this modifier is set, the pattern is forced to be
	  "anchored", that is, it is constrained to match only at the
	  start of the string which is being searched (the "subject
	  string").  This effect can also be achieved by appropriate
	  constructs in the pattern itself, which is the only way to
	  do it in Perl.
	 </P
></DD
><DT
><I
CLASS="emphasis"
>D</I
> (PCRE_DOLLAR_ENDONLY)</DT
><DD
><P
>&#13;	  If this modifier is set, a dollar metacharacter in the pattern
	  matches only at the end of the subject string. Without this
	  modifier, a dollar also matches immediately before the final
	  character if it is a newline (but not before any other
	  newlines).  This modifier is ignored if <I
CLASS="emphasis"
>m</I
>
	  modifier is set. There is no equivalent to this modifier in
	  Perl.
	 </P
></DD
><DT
><I
CLASS="emphasis"
>S</I
></DT
><DD
><P
>&#13;	  When a pattern is going to be used several times, it is
	  worth spending more time analyzing it in order to speed up
	  the time taken for matching. If this modifier is set, then
	  this extra analysis is performed. At present, studying a
	  pattern is useful only for non-anchored patterns that do not
	  have a single fixed starting character.
	 </P
></DD
><DT
><I
CLASS="emphasis"
>U</I
> (PCRE_UNGREEDY)</DT
><DD
><P
>&#13;	  This modifier inverts the "greediness" of the quantifiers so
	  that they are not greedy by default, but become greedy if
	  followed by "?". It is not compatible with Perl. It can also
	  be set by a (?U) modifier setting within the pattern.
	 </P
></DD
><DT
><I
CLASS="emphasis"
>X</I
> (PCRE_EXTRA)</DT
><DD
><P
>&#13;	  This modifier turns on additional functionality of PCRE that
	  is incompatible with Perl. Any backslash in a pattern that
	  is followed by a letter that has no special meaning causes
	  an error, thus reserving these combinations for future
	  expansion. By default, as in Perl, a backslash followed by a
	  letter with no special meaning is treated as a literal.
	  There are at present no other features controlled by this
	  modifier.
	 </P
></DD
></DL
></DIV
></BLOCKQUOTE
>
    </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="function.preg-grep.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="manual.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="pcre.pattern.syntax.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>preg_grep</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="ref.pcre.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Pattern Syntax</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>